# 面试题

## 浏览器

### fetch与XMLHttpRequest

#### fetch的缺点：

* 浏览器支持不好
* 默认无cookie
* 错误不会被拒绝
* 不支持超时
* 终止fetch
* 不支持progress

### [浏览器的缓存机制](https://www.jianshu.com/p/54cc04190252)

![](../.gitbook/assets/image%20%289%29.png)

## React

### 渲染原理

#### 节点类型

* DOM节点
* 文本节点
* 空节点
* 数组节点
* 组件节点：函数组件和类组件

![](../.gitbook/assets/image%20%287%29.png)

#### 对比更新

* key值的作用用于通过旧节点找到对应的新节点，key值应该在一定范围内唯一\(兄弟节点中\)并保持稳定

## 工程化

### webpack

#### 原理

1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；
2. 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；
3. 确定入口：根据配置中的 entry 找出所有的入口文件；
4. 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
5. 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

#### 代码分割

#### sourceMap

[base64 VQL](http://www.qiutianaimeili.com/html/page/2019/05/89jrubx1soc.html)



## 性能优化

### 传输

#### 资源加载时序

defer、async、url combo、资源位置

#### ssr

#### 缓存

端内缓存

模块缓存

#### 资源大小

* 压缩
* tree-shaking
* code-splitting



### 渲染

#### virtual dom

#### 图片懒加载：

intersection observer



## http

### http状态码

#### 1XX\(临时响应\)：表示临时响应并需要请求者继续执行操作的状态码

```text
100 //继续 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分
101 //切换协议 请求者已要求服务器切换协议，服务器已确认并准备切换。
```

#### 2XX\(成功\)：表示成功处理了请求的状态码

```text
200     //成功  服务器已经成功处理了请求。通常，这表示服务器提供了请求的网页。
201     //已创建  请求成功并且服务器创建了新的资源
202     //已接受  服务器已接受请求，但尚未处理
203     //非授权信息  服务器已经成功处理了请求，但返回的信息可能来自另一来源
204     //无内容  服务器成功处理了请求，但没有返回任何内容
205     //重置内容  服务器成功处理了请求，但没有返回任何内容
206     //部分内容  服务器成功处理了部分GET请求
```

#### 3xx\(重定向\)：表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向

```text
300     //多种选择  针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择。
301     //永久移动  请求的网页已永久移动到新位置。服务器返回此响应（对GET或HEAD请求的响应）时，会自动将请求者转到新位置。
302     //临时移动  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
303     //查看其它位置  请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码
304     //未修改  自动上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容
305     //使用代理  请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理
307     //临时性重定向  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求
```

#### 4xx\(请求错误\)：这些状态码表示请求可能出错，妨碍了服务器的处理

```text
400     //错误请求  服务器不理解请求的语法
401     //未授权  请求要求身份验证。对于需要登录的网页，服务器可能返回此响应
403     //禁止  服务器拒绝请求
404     //未找到  服务器找不到请求的网页
405     //方法禁用  禁用请求中指定的方法
406     //不接受  无法使用请求的内容特性响应请求的网页
407     //需要代理授权  此状态码与401（未授权）类似，但指定请求者应当授权使用代理
408     //请求超时  服务器等候请求时发生超时
409     //冲突  服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。
410     //已删除  如果请求的资源已永久删除，服务器就会返回此响应
411     //需要有效长度  服务器不接受不含有效内容长度标头字段的请求
412     //未满足前提条件  服务器未满足请求者在请求者设置的其中一个前提条件
413     //请求实体过大  服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力
414     //请求的URI过长  请求的URI（通常为网址）过长，服务器无法处理
415     //不支持媒体类型  请求的格式不受请求页面的支持
416     //请求范围不符合要求  如果页面无法提供请求的范围，则服务器会返回此状态码
417     //未满足期望值  服务器未满足“期望”请求标头字段的要求
```

#### 5xx\(服务器错误\)：这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。

```text
500     //服务器内部错误  服务器遇到错误，无法完成请求
501     //尚未实施  服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码
502     //错误网关  服务器作为网关或代理，从上游服务器无法收到无效响应
503     //服务器不可用  服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态
504     //网关超时  服务器作为网关代理，但是没有及时从上游服务器收到请求
505     //HTTP版本不受支持  服务器不支持请求中所用的HTTP协议版本
```

### http2.0与http1.1的区别

1、性能提升：http2.0采用二进制分帧层传输数据而不是http1.1的文本格式

2、多路复用：HTTP/1.1的线头阻塞和多个TCP连接的问题，HTTP2的多路复用完美解决。HTTP2让所有的通信都在一个TCP连接上完成，真正实现了请求的并发

3、头部压缩

4、服务器端推送

## CSS

### BFC

## JS

#### 原型

![](../.gitbook/assets/image%20%288%29.png)

### 事件循环

#### 宏任务

setTimeout、setInterval、I/O、UI渲染、setImmeDiate、requestAnimationFrame

#### 微任务

{% embed url="https://Promise、MutationObserver、Process.nextTick" %}

## html

### h5新特性

```text
1、语义化标签：header、footer、section、nav、aside、article
2、增强型表单：input 的多个 type
3、新增表单元素：datalist、keygen、output
4、新增表单属性：placehoder、required、min 和 max
5、音频视频：audio、video
6、canvas
7、地理定位
8、拖拽
9、本地存储：localStorage - 没有时间限制的数据存储；
   sessionStorage - 针对一个 session 的数据存储，当用户关闭浏览器窗口后，数据会被删除
10、新事件：onresize、ondrag、onscroll、onmousewheel、onerror、onplay、onpause
11、WebSocket：单个 TCP 连接上进行全双工通讯的协议
```

## SEO

1、合理的title、description、keywords：搜索对这三项的权重逐个减小，title值强调重点即可；description把页面内容高度概括，不可过分堆砌关键词；keywords列举出重要关键词。

2、语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页

3、重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，保证重要内容一定会被抓取

4、重要内容不要用js输出：爬虫不会执行js获取内容

5、少用iframe：搜索引擎不会抓取iframe中的内容

6、非装饰性图片必须加alt

7、提高网站速度：网站速度是搜索引擎排序的一个重要指标

#### [前后端分离的项目如何seo](https://developers.google.com/search/docs/guides/dynamic-rendering)

1、使用prerender。但是回答prerender，面试官肯定会问你，如果不用prerender，让你直接去实现，好的，请看下面的第二个答案。

2、先去 www.baidu.com/robots.txt 找出常见的爬虫，然后在nginx上判断来访问页面用户的User-Agent是否是爬虫，如果是爬虫，就用nginx方向代理到我们自己用nodejs + puppeteer实现的爬虫服务器上，然后用你的爬虫服务器爬自己的前后端分离的前端项目页面，增加扒页面的接收延时，保证异步渲染的接口数据返回，最后得到了页面的数据，返还给来访问的爬虫即可

